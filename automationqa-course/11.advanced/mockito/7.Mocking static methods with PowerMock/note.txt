В предыдущих частях текущего курса по Мокито мы рассмотрели все основные возможности этого фрэймворка.
Среди рассмотренного не оказалось способности мокать статические методы. И это неспроста.
Дело в том, что у Мокито нет такой способности. Причина в том, что авторы Мокито
предпочитают хороший код с ориентацией на объекты и внедрение зависимостей (DI) над процедурным стилем программирования,
который в Java реализуется через использование статических методов. Сами по себе статические методы -
это не обязательно плохо. Главное, чтобы их поведение должно быть детерменистическим и не очень сложным.
Хорошим примером является, например, статический метод Math.max, выбирающие максимальное значение из двух переданных.
В сожалению, чаще всего код, написанный в процедурном стиле, сложно понять и сложно изменить.
На текущем занятии мы посмотрим на небольшой пример кода, с которым мне приходилось работать,
и вы сами сможете оценить его понятность и сложность.
Реальность такова, что в жизни нам может достаться код или, хуже, стороннее API в этом стиле.
Тесты писать всё равно необходимо, а раз так, то подключим себе возможность мокирования статических
методов. Это мы сделаем с помощью фрэймворка PowerMock. Он расширяет возможности Мокито.
Добавляет возможность не только мокирования стических методов, но и вызова конструкторов объектов
и даже закрытых (приватных) методов. Вообще говоря, приватные методы являются закрытой частью реализации
классов, а значит мокировать их точно не стоит - они не для тестов! Мокать вызовы конструкторов - тоже в
обычной жизни плохая затея. А вот статические методы часто бывают реальностью. На этом занятии мы рассмотрим
именно проверку взаимодействия с ними и полностью пропустим рассмотрение вызовов конструкторов и
закрытых методов.
Хочу обратить ваше внимание, что авторы PowerMock в документации на свой продукт явно указывают,
что этот фрэймворк в первую очередь предназначен для людей с экспертными знаниями в области модульного
тестирования. Если PowerMock попадёт в руки начинающего программиста, то, возможно, это причинит
больше вреда, чем пользы. Поэтому будьте более внимательны. Возможно, если вы активно применяете
PowerMock, то что-то пошло не в ту сторону.

В качестве первого модуля для тестирования в этом занятии возьмём класс SomeContoller <Открываем SomeController>.
Этот класс с единственным методом calculateHash, принимающего массив байт исходного документа, вычисляющего хэш этого массива,
который тоже представляет собой массив байт, и возвращающего его. Проблема в том, что метод calculateHash
использует внутри себя статические методы класса Encryptor <Открываем Encryptor>.
Encryptor в себе содержит разные методы для осуществления разных криптографических операций.
Здесь представлена вырезка из реального класса - всего 4 метода для подсчёта хэша массива байт.
Все эти методы статические нативные. Т.е. по факту имеется подключаемая нативная динамическая
библиотека, которая реализует соответствующие методы. Для работы с реальной реализацией этих
методов, эту библиотеку в приложении нужно будет загрузить. Нам для осуществления тестовых
сценариев хотелось бы исключить эту загрузку, так как тестировать библиотеку мы не собираемся.
Давайте посмотрим внимательнее на класс Encryptor. Все его методы hash_open, hash_calc, hash_return и hash_close
возвращают целочисленное значение, которое представляет собой результат выполнения операции.
Это типичное решение для подобных методов. Чаще всего ненулевое возвращаемое значение говорит об ошибке при
выполнении операции.
hash_open принимает на вход массив long'ов. Эта операция инициализирует процесс вычисления хэша,
открывает необходимые буферы, возвращает хэндл, который нам понадобится для проведения цепочки
операций по расчёту хэша. Обратим внимание на тот факт, что Java может возвращать только одно значение в методе,
для получения значения хэндла приходится делать ход конём - в аргумент метода передавать массив
лонгов, если операция будет выполнена успешно, то в первом элементе этого массива окажется нужное
нам значение хэндла.
hash_calc принимает на вход хэндл операции, полученный с помощью hash_open, и массив байт,
хэш которых нужно посчитать. hash_calc может вызываться последовательно для каждого переданного
блока данных.
Метод hash_return через атрибут возвращает вычисленное значение хэша.
Метод hash_close должен быть _обязательно_ вызван, если был успешный hash_open. Он освобождает занятые
ресурсы. Если его не вызвать, то последствия для приложения, запущенного в промышленную эксплуатацию
могут быть крайне плачевными.
Вернёмся назад к реализации тестируемого нами модуля SomeController. Мы видим, что сначала выполняется
метод hash_open, получается хэндл, потом этот хэндл используется при последовательном вызове методов
hash_calc, hash_return и hash_close. hash_close находится в блоке finally для того, чтобы освободить
занятые ресурсы. Он должен быть вызван, если hash_open был успешным.
Если вычисление хэша было неуспешным, то бросается исключение UnableToCalcHashException.
Ошибка при выполнении hash_open является фаталистическим сценарием - что делать в таких случаев
не знает никто, поэтому система просто залогирует такое событие, хэш будет возвращён.
С реализацией модуля разобрались, давайте напишем тест.
Первым делом нам понадобится успешный тест, который проверит, что все 4 метода вызывались.

На SomeController'е делаем create test.
Добавляем в pom.xml зависимости.
Добавляем
@RunWith(PowerMockRunner.class)
@PrepareForTest(Encryptor.class)
Обращаем внимание, что это стиль JUnit4 актуальный для мокито в настоящий момент.
Добавляем в setUp mockStatic(Encryptor.class);
Пишем тест testCalculateHash.
Стабы мы пишем в обычном для Мокито стиле.
А вот стадия верификэйшн немного непростая - нужно вызывать verifyStatic перед каждой проверкой.
Убеждаемся, что всё работает.
        // Пример мы выполнили и увидели, что PowerMock работает. Но как он это делает?
        // А делает это он путём модификации байт-кода во время исполнения тестов.

Далее вспоминаем, что неплохо было бы проверить, что хэндл во все методы передаётся нужный - тот,
что вернулся методом hash_open.
Модифицируем testCalculateHash.
Показываем, что в Мокито есть ещё возможность работы с ответами. Используем их для создания стаба, который
возвращает заранее подготовленный хэндл.

Добавляем тест, который проверяет, что hash_close выполнится, если ошибка будет в hash_calc. При этом
hash_return не должен исполняться.

Далее переходим к тому, что часто нам приходится иметь дело со статическими методами системной части
Java - например, System.currentTimeInMillis. Современная реализация PowerMock позволяет мокать даже
вызовы системных статических методов. Пишем тест CurrentTimeInMillisTest.