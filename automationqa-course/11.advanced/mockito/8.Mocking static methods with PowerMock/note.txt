В предыдущих частях этого курса мы рассмотрели почти все основные возможности фрэймворка Мокито.
Среди рассмотренного не оказалось способности мокать статические методы.
Причина в том, что авторы фрэймворка не стали добавлять такую способность ввиду предпочтений
на код с объектной ориентацией над процедурным стилем программирования,
который в Java реализуется через статические методы. Этим шагом они хотят стимулировать
писать правильный код всех.
Сами по себе статические методы - это не обязательно плохо.
Главное, чтобы их поведение было детерменистическим и не очень сложным.
Положительным примером является статический метод выбора максимального значения из 2-х аргументов - Math.max.
К сожалению, чаще всего код, написанный в процедурном стиле, сложно понять и сложно изменить.
На текущем занятии я покажу небольшой пример кода, с которым мне пришлось работать,
и вы сами сможете оценить его понятность и сложность.
Реальность такова, что в жизни может достаться стороннее API в процедурном стиле.
Тесты по взаимодействию с эти API писать всё равно нужно. Раз так, то подключим себе возможность мокирования статических
методов. Это мы сделаем с помощью фрэймворка PowerMock, который расширяет возможности Мокито.
Он добавляет возможность не только мокать статические методы, но и вызовы конструкторов объектов
и даже закрытые (приватные) методы. Вообще говоря, приватные методы являются закрытой частью реализации
классов, а значит мокировать их не стоит - они не для тестов! Мокать вызовы конструкторов - тоже в
обычной жизни плохая затея. А вот статические методы могут быть реальностью. На этом занятии мы рассмотрим
именно проверку взаимодействия с ними и полностью пропустим рассмотрение вызовов конструкторов и
закрытых методов.
Хочу обратить ваше внимание, что авторы PowerMock в документации на свой продукт явно указывают,
что этот фрэймворк в первую очередь для людей с экспертными знаниями в области модульного
тестирования. Если PowerMock попадёт в руки начинающего программиста, то, возможно, это причинит
больше вреда, чем пользы. Поэтому будьте внимательны - возможно, если вы активно применяете
PowerMock, то что-то пошло не в ту сторону.

В качестве первого модуля для тестирования возьмём класс SomeContoller <Открываем SomeController>.
Это класс с единственным методом calculateHash, принимающим массив байт исходного документа, вычисляющим хэш этого массива
и возвращающим его. Проблема в том, что метод calculateHash
использует внутри себя статические методы класса Encryptor <Открываем Encryptor>.
Encryptor в себе содержит разные методы для осуществления криптографических операций.
Здесь представлена вырезка из реального класса - 4 метода для подсчёта хэша массива байт.
Все эти методы представляют стороннее API и являются статическими нативными.
По факту имеется подключаемая динамическая библиотека, содержащая реализацию соответствующих методов.
Для работы с этой библиотекой в Java, её придётся в приложении сначала загрузить, что не бесплатно.
Нам для осуществления тестовых сценариев хотелось бы исключить такую загрузку, тестировать библиотеку мы не собираемся.
Давайте посмотрим внимательнее на класс Encryptor. Все его методы hash_open, hash_calc, hash_return и hash_close
возвращают целочисленное значение, которое представляет собой результат выполнения операции.
Это типичное решение для подобных методов в процедурном стиле.
Ненулевое возвращаемое значение говорит об ошибке при выполнении операции.
hash_open принимает на вход массив long'ов. Эта операция инициализирует процесс вычисления хэша,
открывает необходимые буферы, возвращает хэндл, который нам понадобится для проведения цепочки
операций по расчёту хэша. Обратим внимание на тот факт, что Java может возвращать только одно значение в методе,
для получения значения хэндла приходится делать ход конём - в аргумент метода передавать массив
лонгов, если операция будет выполнена успешно, то в первом элементе этого массива окажется нужное
нам значение хэндла.
hash_calc принимает на вход хэндл операции, полученный ранее с помощью hash_open, и массив байт,
хэш которых нужно посчитать. hash_calc может вызываться последовательно для каждого переданного
блока данных.
Метод hash_return через атрибут возвращает вычисленное значение хэша.
Метод hash_close должен быть _обязательно_ вызван, если был успешный hash_open. Он освобождает занятые
ресурсы. Если его не вызвать, то последствия для приложения, запущенного в промышленную эксплуатацию,
могут быть крайне плачевными.
Вернёмся назад к реализации SomeController, модуля, который мы собираемся тестировать. Видим, что сначала выполняется
метод hash_open, получается хэндл, потом этот хэндл используется при последовательном вызове методов
hash_calc, hash_return и hash_close. hash_close находится в блоке finally для того, чтобы освободить
занятые ресурсы. Он должен быть вызван, если hash_open был успешным.
Если вычисление хэша было неуспешным, то бросается исключение UnableToCalcHashException.
С реализацией модуля разобрались, давайте напишем тест.
Первым делом нам понадобится успешный тест, который проверит, что все 4 метода вызывались.

На SomeController'е делаем create test.
Добавляем в pom.xml зависимости.
Добавляем
@RunWith(PowerMockRunner.class)
@PrepareForTest(Encryptor.class)
Обращаем внимание, что это стиль JUnit4 актуальный для PowerMock в настоящий момент.
Добавляем в setUp mockStatic(Encryptor.class);
Пишем тест testCalculateHash.
Стабы мы пишем в обычном для Мокито стиле.
А вот стадия верификэйшн посложнее - нужно вызывать verifyStatic перед каждой проверкой.
Убеждаемся, что всё работает.

Далее вспоминаем, что неплохо было бы проверить, что хэндл во все методы передаётся нужный - тот,
что вернулся методом hash_open. Нужно сделать заглушку на hash_open такой, чтобы использовать своё значение хэндла.
Модифицируем testCalculateHash.
В Мокито мы не рассмотрели возможность работы с механизмом ответов. Он как раз нам сейчас понадобится.
Используем его для создания стаба, который возвращает заранее подготовленный хэндл.

Добавляем тест, который проверяет, что hash_close выполнится, если ошибка будет в hash_calc. При этом
hash_return не должен исполняться.

Далее переходим к тому, что часто нам приходится иметь дело со статическими методами системной части
Java - например, System.currentTimeInMillis. Современная реализация PowerMock позволяет мокать даже
вызовы системных статических методов. Пишем тест CurrentTimeInMillisTest.
