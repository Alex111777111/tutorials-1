Все примеры, которые мы рассматривали до этого момента использовали для создания заглушек и проверки
вызовов методов точное совпадение по значению объекта. Мокито в данном случае использует
метод equals переданных аргументов. Однако такая точность не всегда удобна. Мокито имеет в своём
составе гибкий механизм сопоставления аргументов. В этой части курса мы познакомимся с ним.
Вернёмся к примеру из прошлой части - тест для модуля Order. Модифицируем его таким образом, чтобы
подарок конфета добавлялся к каждому приобретённому товару.

<
Возвращаемся к предыдущему состоянию OrderTest из прошлой части.
Пишем testCandyForAnyItem.
Обращаем внимание на any(). Смотрим внутрь ArgumentMatchers. Видим, что там много, что есть.
Добавляем второй тест - testNoCandyForItemsLessThan100, он будет использовать кастомный ответ argThat.
Потом добавляем testCandyForItemsMoreThan100.
Следующим - говорит, что ArgumentMatchers актуальны и для проверки вызовов методов - смотрим
testArgumentMatchersOnVerify.
Снова обращаем внимание, что по умолчанию Мокито использует методы equals hashCode в своей работе
матчеров. А потому одним из ограничений Мокито является запрет на мокание этих методов. Смотрим на примере:
пишем DontMockEqualsHashCodeTest, который вернёт соответствующую ошибку.

В конце говорим, что Мокито представляет синонимы своих стандартных статических методов, чтобы
в итоге код теста получался в BDD стиле. Смотрим пример - возвращаемся к OrderTest'у, модифицируем
testCandyForAnyItem в testCandyForAnyItemBddStyle.
>