Все примеры, которые были нами рассмотрены до этого момента, использовали для создания заглушек и проверки
аргументов вызванных методов совпадение по значению объекта. Мокито в данном случае использует
метод equals значений. Однако такое поведение (сравнение по equals) не всегда удобно.
В добавок, при написании заглушек часто необходимо написать универсальный ответ,
 который возвращается для целого набора возможных
значений аргументов. Мокито имеет в своём составе гибкий механизм сопоставления аргументов.
 В этой части курса мы познакомимся с ним.
Вернёмся к примеру из прошлой части - тест для модуля Order.

Сделаем пример заглушки, которая будет возвращать в качестве подарка конфету при покупке любого товара.
<Делаем testCandyForAnyItem>
Обратите внимание на то, какой набор методов any существует в мокито.
<открываю всё, что any*>

Сделаем другой тестовый метод - давайте сделаем заглушку, которая возвращает конфету в качестве подарка
к любому товару, цена которого превышает 100 единиц. В тестовой заглушку нам придётся
написать свой матчер с помощью статического метода argThat.
<Делаем testNoCandyForItemsLessThan100, потом testCandyForItemsMoreThan100>
    void testNoCandyForItemsLessThan100() throws InsufficientFundsException {
        when(promotionService.getGiftsByItem(argThat(
                (item) -> valueOf(100).compareTo(item.getPrice()) < 0
        ))).thenReturn(singletonList(candy));
                        () -> assertFalse(items.contains(candy), "Подарок не добавлен в список приобретённых товаров")
Argument matcher'ы могут использоваться и в блоках verify. В verify удобно использовать argument matcher'ы,
если нужна своя кастомизированная проверка на то, объект с какими характеристиками был передан в аргументе метода.

    void testArgumentMatchersOnVerify() throws InsufficientFundsException {
        assertAll(
                () -> verify(account).withdraw(any()),
                () -> verify(account).withdraw(argThat((price) -> valueOf(100).compareTo(price) < 0)),

                // Проверит на то, что getGiftsByItem был вызван именно с тем же аргументом, что и был передан в buyItem
                // (проверка на равенство ссылок, а не equals)
                () -> verify(promotionService).getGiftsByItem(same(car)),

                () -> assertTrue(items.contains(car), "Автомобиль добавлен в список приобретённых товаров"),
                () -> assertTrue(items.contains(candy), "Подарок добавлен в список приобретённых товаров")
        );

Напомню ещё раз, по умолчанию Мокито использует методы equals hashCode в работе матчеров.
А потому одним из ограничений Мокито является запрет на создание заглушек этих методов.
 Не пытайтесь сделать заглушки этих методов!