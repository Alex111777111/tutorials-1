В  этой части курса я расскажу вам, как подключить мокито к проекту. Мы рассмотрим разные варианты создания моков и напишем простые тесты, проверяющие поведение объектов.
В качестве примера возьму проект с клиентскими заказами, который использовался в предыдущей презентации. Для начала добавим зависимость на mockito-core в pom.xml.
<Добавляю mockito-core, выношу проперть с версией отдельно>
Класс Order, тесты к которому я буду писать, вы видите сейчас на экране. Создам для этого модуля тест. <Добавляю OrderTest>
В тесте нам понадобится экземпляр Order'а. Его мы будем использовать в каждом тестовом методе. <Добавляю private final Order order = new Order();>
Конструктора без аргументов у Order'а нет. Создадим мок для PromotionService'а, который и передадим в качестве аргумента. Этому моку мы сможем задавать заглушки
на вызовы определённых методов. Его же сможем использовать для проверки взаимодействия Order'а с имплементацией PromotionService'а.
<Добавляю private final PromotionService promotionService = mock(PromotionService.class);>
Добавим первый тестовый метод - проверим случай успешной покупки товара. <Добавляю testSuccedIfEnoughFunds>
Допустим, покупать клиент будет пирожное: <Добавляю в тестовый метод Item cake = new Item("Cake", valueOf(70));>
Добавляю вызов проверяемого действия: <Добавляю order.buyItem(cake, ...);>
Для вызова этого метода нам понадобится реализация интерфейса банковского счёта. Создадим мок такого интерфейса.
<Добавляю private final BankAccount account = mock(BankAccount.class); потом order.buyItem(cake, account);>
Вызов метода buyItem написан. Теперь добавим необходимые тестовые утверждения.
Первое утверждение - что вызвался метод withdraw с ценой пироженого.
<Добавляю verify(account).withdraw(cake.getPrice());>
Второе утверждение - что у PromotionService'а был вызван метод getGiftsByItem - т.е. при покупке товара был запрошен список подарков.
<Добавляю verify(promotionService).getGiftsByItem(cake);>
Третье утрвеждение, что купленное пироженое было добавлено в список приобретённых товаров.
<Добавляю assertTrue(order.getItems().contains(cake), "Пирожное добавлено в список приобретённых товаров");>
Тестовый метод готов, запустим его, чтобы проверить верность реализации. <Запускаю тест>
Тест пройден успешно - значит реализация соответствует ожиданию. В данном примере моки созданы в виде приватных членов класса.
Это допустимо, так как JUnit на каждый вызов тестового метода создаёт новый инстанс тестового класса, ведь тесты должны быть изолированны.
Есть один момент, на который стоит обратить внимание - важен порядок членов класса. Инстанс класса Order должен быть создан после создания мока PromotionService'а,
так как последний требует ёёся в конструкторе Order'а - java инциализирует члены класса в порядке их определения. Наш пример довольно прост, поэтому особых
проблем с инициализацией членов класса нет. Бывают случаи, когда инициализация более сложная - в таких случаях предпочтительно использовать метод с аннотацией @BeforeEach.
Перепишем этот пример в вид с таким методом. <Переписываю - моки создаю в BeforeEach, запускаю тест - убеждаюсь, что всё ОК>
Использовать или нет BeforeEach - решать вам. Если нужен отдельный метод инициализации - делайте. Не нужен - лучше использовать нестатические приватные члены класса.
В мокито есть альтернативный вариант определения моков - с помощью аннотации. Для этого пометим моки аннотацией @Mock. В метод с @BeforeEach нужно добавить вызов
статического метода initMocks. <Запускаю тест - убеждаюсь, что всё ОК>
Тест стал более чистым, более декларативным. Можно сделать его ещё немного более чистым - давайте избавимся от метода initMocks. В JUnit 5 есть
возможность подключения расширений - подключим нужную нам. Для этого сначала добавим зависимость на mockito-junit-jupiter. <Добавляю mockito-junit-jupiter в pom.xml>
Теперь к тестовому классу добавим аннотацию @ExtendWith(MockitoExtension.class). initMocks можно удалить - он больше не нужен. К сожалению,
от инициализации Order'а в BeforeEach не избавиться. <Удаляю initMocks, проверяю, что всё работает>
Есть ещё одна аннотация в мокито, которая иногда делает тесты ещё более понятными - InjectMocks, но я не рекомендую её часто использовать - всё-таки мокито это не
dependency injection фрэймворк. Работу с этой аннотацией я предлагаю освоить вам самостоятельно.
В данной части курса мы рассмотрели несколько вариантов подключения моков к тестам и можем в следующей части уже приступить к основным способностям Мокито.