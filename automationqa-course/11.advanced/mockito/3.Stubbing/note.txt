В этой части курса я расскажу о том, как писать стабы с помощью Мокито.
Мокито предоставляет широкий спектр возможностей для написания заглушек и использование таких возможностей крайне простое.
Вернёмся к нашему проекту с клиентскими заказами.
Я хочу написать тест, который проверит, что сервис по получению подарков при покупке товаров вызывается, и
подарки добавляются в список товаров заказа. Добавлю тестовый метод testGiftsAddedToOrderItems.
Создам объект - конфета, она и будет подарком покупателю пирожного.
Добавим заглушку на метод getGiftsByItem, которая вернёт список из одного элемента (конфеты), в случае
вызова этого метода с пирожным.
Если вызывается метод promotionService.getGiftsByItem с аргументом cake, то вернуть список из одной конфеты.
<Добавляю when(promotionService.getGiftsByItem(cake)).thenReturn(singletonList(candy));>
Добавляем необходимое утверждение assertTrue(order.getItems().contains(cake)).
Проверяем.
<Запускаю тест>
Ещё раз обратите внимание, как легко можно создавать заглушки.
Теперь давайте более внимательно остановимся на разных вариантах написания заглушек.
Будем писать заглушки к интерфейсу List. Добавим тест StubbingListsTest.
Создадим мок интерфейса List. <Добавляю private final List<Integer> mockedList = mock(List.class);>
Т.е. в нашем списке будут находиться целые числа.
Обратите внимание, нам среда подсказывает, что есть unchecked warning. Конкретно в данном случае такое предупреждение
можно подавить.
Мы написали мок для интерфейса, но на самом деле можно мокать и конкретные реализации - ограничений
здесь нет, важен список методов класса.
Посмотрим, как можно писать заглушки для методов, возвращающих значения.
<Добавляю testStubbingMethodWithReturnValue.>
Напишем заглушку на вызов метода get с аргументом 0 - если будет вызываться get для 0-го элемента,
то возвращать 1.
Если мы написали такую заглушку, то get(0) всегда будет возвращать 1, сколько бы раз мы его не вызвали.
Как быть, если мы хотим, чтоб


Обратите внимание, я не делал заглушки финальным методам и не делал моки финальных классов.
Изначально мокито не предполагал такой возможности - она считалась ненужной. Начиная с версии 2.1.0
такая возможность появилась, но она пока является экпериментальной, поэтому мы её рассматривать не будем.
Посмотрим на примере, какое сообщение вернёт среда, если попытаться замокать финальный класс. Такой
класс у нас есть - это Item. Напишем тест, который пытается его замокать.

На этом занятии мы изучили возможности мокито по написанию заглушек. В следующем поговорим о матчере аргументов,
такие матчеры позволят писать тестовые заглушки ещё более гибко.